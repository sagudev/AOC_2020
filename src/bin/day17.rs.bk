use std::iter::FromIterator;
use std::collections::VecDeque;
use aoc::read_data;
use std::collections::HashMap;
use std::convert::Infallible;
use std::error::Error;
use std::str::FromStr;

#[derive(Debug, Clone, PartialEq)]
enum Cube {
    Active,
    /// free seat
    Inactive,
}

impl std::fmt::Display for Cube {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Cube::Inactive => write!(f, "."),
            Cube::Active => write!(f, "#"),
        }
    }
}

impl Cube {
    fn from_char(c: char) -> Self {
        match c {
            '.' => Cube::Inactive,
            '#' => Cube::Active,
            _ => panic!("wrong Cube"),
        }
    }
}

struct Grid {
    /// (x, y, z)
    a: HashMap<(i32, i32, i32), Cube>
}

fn cikel(grid: &mut Grid) {
    grid.
}

fn p1(data: &Grid) -> usize {
    let mut data = data.clone();
    let mut count = 0;
    // 6 ciklov
    for _ in 1..=6 {
        cikel(&mut data)
    }
    for v in data.z.values() {
        for d in &v.yx {
            for r in &d.row {
                if *r == Cube::Active {
                    count += 1;
                }
            }
        }
    }
    count
}

fn p2(data: &D3) -> usize {
    5
}

fn main() -> Result<(), Box<dyn Error>> {
    println!("Hello, Advent Of Code 2020!");
    let data: Vec<Row> = read_data("./data/data16").unwrap();
    let data = trans(data);
    // part 1
    println!(
        "How many cubes are left in the active state after the sixth cycle? {}",
        p1(&data)
    );
    // part 2
    println!("Given the new visibility method and the rule change for occupied seats becoming empty, once equilibrium is reached, how many seats end up occupied? {}", p2(&data));
    Ok(())
}

#[test]
fn data_read17() {
    println!("{:?}", read_data::<Row>("./data/data16").unwrap());
}

#[test]
fn calc17() {
    let data = vec![".#.", "..#", "###"];
    let mut data = trans(
        data.iter()
            .map(|line| line.trim().parse().unwrap())
            .collect(),
    );
    // part 1
    println!("{}", data);
    cikel(&mut data);
    println!("{}", data);
    //assert_eq!(p1(&data), 112);
    // part 2
}
